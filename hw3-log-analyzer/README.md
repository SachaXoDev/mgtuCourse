# Проект №3 "Анализатор логов"

## 1. Описание проекта

Лог-файлы являются важной частью работы любого сервера, так как они содержат информацию о том, какие запросы были
отправлены на сервер, какие ошибки возникли и какие действия были выполнены. Однако, обрабатывать и анализировать
эти логи вручную может быть очень трудоемким процессом.

К примеру, в крупных компаниях для решения данной задачи, достаточно часто, используют такой технологический стэк,
как [ELK (Elasticsearch, Logstash, Kibana)](https://www.elastic.co/elastic-stack).
В Т-Банк используется собственное решение - [**Sage**](https://www.tbank.ru/career/technologies/sage/).
Подробнее с этими технологиями мы познакомимся с вами в следующем семестре :)

Сегодня же, для решения описанной выше проблемы, давайте напишем собственную программу-анализатор логов NGINX!

## 2. Функциональные требования

### 1. Интерфейс программы

Программа должна представлять из себя утилиту командной строки, которая принимает на вход следующие параметры:

- `--path, -p` - путь к одному или нескольким NGINX лог-файлам
    - файлы могут быть как **локальными** (путь до локального
      файла, [шаблон для локальных файлов](https://en.wikipedia.org/wiki/Glob_(programming))),
      так и **удалёнными** (URL ссылка на файл). К примеру:
        - `/var/log/nginx/server.log`
        - `logs/2025*`
        - `https://raw.githubusercontent.com/elastic/examples/master/Common%20Data%20Formats/nginx_logs/nginx_logs`
    - файлы могут быть в формате `.txt`, `.log`
    - программа должна завершать свою работу с **ошибкой**, если
        - файл не соответствует поддерживаемому формату
        - файл по указанному пути не найден
            - в случае, если запрошен файл по конкретному пути
            - в случае, если запрошен удаленный файл, а внешняя система ответила с кодом 404

- `--format, -f` - необязательный параметр, указывающий на формат вывода результатов.
    - необходимо реализовать поддержку следующих форматов:
        - `json`
        - `markdown`
        - `adoc` - **(не обязателен к реализации, +доп. баллы)**
    - программа должна завершать свою работу с **ошибкой**, если на вход передан неподдерживаемый формат

- `--output, -o` - путь до файла, куда должен быть сохранён результат работы программы
    - программа должна завершить свою работу с ошибкой, если:
        - файл по указанному пути уже существует
        - директория недоступна для записи
        - расширение файла не соответсвует ожидаемому
            - в случае `markdown` - `.md`
            - в случае `adoc` - `.ad`
            - в случае `json` - `.json`

- `--from, --to` - два **необязательных** параметра с датами в формате **ISO8601**
    - программа должна завершать свою работу с **ошибкой**, если:
        - `from >= to`
        - даты не соответствуют формату ISO8601
    - возможны следующие комибинации параметров:
        1. `from <> null` && `to <> null` - необходимо проанализировать логи в указанном временном диапазоне
           (с даты `from` по дату `to` включительно)

        2. `from <> null` && `to == null` - необходимо проанализировать логи с даты `from` включительно по последнюю
           доступную в логах дату

        3. `from == null` && `to <> null` - необходимо проанализировать логи с первой доступной в логах даты по дату
           `to`
           включительно

        4. `from == null` && `to == null` - необходимо проанализировать все доступные логи в файле

При реализации не забывайте, что программа представляет из себя **консольную утилиту**.
Поэтому, любое исключение в приложении должно транслироваться в соответсвующий код возврата:

- `0` - программа успешно завершила свою работу
- `1` - непредвиденная ошибка
- `2` - некорректное использование программы (неверные параметры, отсутствие файлов и т.д.)

**Пример запуска программы:**

```shell
java -jar log-analyzer.jar --path logs/*.log --format markdown --output report.md --from 2025-03-01
```

### 2. Формат обрабатываемых данных

Программа должна быть способна обрабатывать логи NGINX-сервера в приведенном ниже формате. В случае, если
по какой-то причине строка не соответсвует данному формату, данная непредвиденная ситуация должна быть залогирована с
уровнем логирования WARN, а сама строка - пропущена.

```
'$remote_addr - $remote_user [$time_local] ' '"$request" $status $body_bytes_sent ' '"$http_referer" "$http_user_agent"'
```

Примеры логов:

```
93.180.71.3 - - [17/May/2015:08:05:32 +0000] "GET /downloads/product_1 HTTP/1.1" 304 0 "-" "Debian APT-HTTP/1.3 (0.8.16~exp12ubuntu10.21)"
93.180.71.3 - - [17/May/2015:08:05:23 +0000] "GET /downloads/product_1 HTTP/1.1" 304 0 "-" "Debian APT-HTTP/1.3 (0.8.16~exp12ubuntu10.21)"
```

Еще больше примеров можно
найти [здесь](https://raw.githubusercontent.com/elastic/examples/master/Common%20Data%20Formats/nginx_logs/nginx_logs).

### 3. Собираемая статистика

На основании данных из логов, программа должна собрать следующую статистику:

- общее количество запросов
- средний и максимальный размер ответа от сервера
- 95% перцентиль размера ответа от сервера
- частота встречаемых кодов ответа
- топ-10 наиболее часто запрашиваемых ресурсов, отсортированных по убыванию
    - при реализации необходимо учесть, что метод запроса не является частью ресурса, т.е. в логе вида
      `"... GET /downloads/product_1 HTTP/1.1.. "` ресурсом является `/downloads/product_1`
- распределение запросов по датам в процентом соотношении от общего числа **(+доп. баллы)**
- уникальные используемые протоколы передачи данных (HTTP/1, HTTP/2, etc) **(+доп. баллы)**

Точность результатов при расчёте статистики должна **быть 2 знака после запятой**.

### 4. Вывод программы

Собранная статистика должна быть сохранена по указанному пути в выбранном пользователем формате.

В случае, если пользователь выбрал формат `json`, результат работы программы должен быть записан
в соответствии со следующей JSON-схемой:

```json
{
    "$schema": "http://json-schema.org/draft-04/schema#",
    "type": "object",
    "properties": {
        "files": {
            "type": "array",
            "items": [
                {
                    "type": "string"
                }
            ]
        },
        "totalRequestsCount": {
            "type": "integer"
        },
        "responseSizeInBytes": {
            "type": "object",
            "properties": {
                "average": {
                    "type": "integer"
                },
                "max": {
                    "type": "integer"
                },
                "p95": {
                    "type": "integer"
                }
            },
            "required": [
                "average",
                "max",
                "p95"
            ]
        },
        "resources": {
            "type": "array",
            "items": [
                {
                    "type": "object",
                    "properties": {
                        "resource": {
                            "type": "string"
                        },
                        "totalRequestsCount": {
                            "type": "integer"
                        }
                    },
                    "required": [
                        "resource",
                        "totalRequestsCount"
                    ]
                }
            ]
        },
        "responseCodes": {
            "type": "array",
            "items": [
                {
                    "type": "object",
                    "properties": {
                        "code": {
                            "type": "integer"
                        },
                        "totalResponsesCount": {
                            "type": "integer"
                        }
                    },
                    "required": [
                        "code",
                        "totalResponsesCount"
                    ]
                }
            ]
        },
        "requestsPerDate": {
            "type": "array",
            "items": [
                {
                    "type": "object",
                    "properties": {
                        "date": {
                            "type": "string"
                        },
                        "weekday": {
                            "type": "string"
                        },
                        "totalRequestsCount": {
                            "type": "integer"
                        },
                        "totalRequestsPercentage": {
                            "type": "number"
                        }
                    },
                    "required": [
                        "date",
                        "weekday",
                        "totalRequestsCount",
                        "totalRequestsPercentage"
                    ]
                }
            ]
        },
        "uniqueProtocols": {
            "type": "array",
            "items": [
                {
                    "type": "string"
                }
            ]
        }
    },
    "required": [
        "files",
        "totalRequestsCount",
        "responseSizeInBytes",
        "resources",
        "responseCodes"
    ]
}
```

Для всех остальных форматов никаких дополнительных требований к выводу данных нет.

Пример вывода в формате `json`:

```json
{
    "files": [
        "access.log",
        "http://example.com/access.log"
    ],
    "totalRequestsCount": 10000,
    "responseSizeInBytes": {
        "average": 500,
        "max": 1000,
        "p95": 950
    },
    "resources": [
        {
            "resource": "/downloads/product_1",
            "totalRequestsCount": 1000
        },
        {
            "resource": "/downloads/product_2",
            "totalRequestsCount": 100
        }
    ],
    "responseCodes": [
        {
            "code": 500,
            "totalResponsesCount": 1
        },
        {
            "code": 401,
            "totalResponsesCount": 10
        },
        {
            "code": 200,
            "totalResponsesCount": 1000
        }
    ],
    "requestsPerDate": [
        {
            "date": "2024-03-01",
            "weekday": "Monday",
            "totalRequestsCount": 2981,
            "totalRequestsPercentage": 12.1
        }
    ],
    "uniqueProtocols": [
        "HTTP/1.1",
        "HTTP/2.0",
        "grpc"
    ]
}
```

Пример вывода в формате `markdown`:

```markdown
#### Общая информация

|        Метрика        |     Значение |
|:---------------------:|-------------:|
|       Файл(-ы)        | `access.log` |
|    Начальная дата     |   31.08.2024 |
|     Конечная дата     |            - |
|  Количество запросов  |       10_000 |
| Средний размер ответа |         500b |
|  95p размера ответа   |         950b |

#### Запрашиваемые ресурсы

|     Ресурс      | Количество |
|:---------------:|-----------:|
|  `/index.html`  |      5_000 |
|  `/about.html`  |      2_000 |
| `/contact.html` |      1_000 |

#### Коды ответа

| Код |          Имя          | Количество |
|:---:|:---------------------:|-----------:|
| 200 |          OK           |       8000 |
| 404 |       Not Found       |       1000 |
| 500 | Internal Server Error |        500 |
```

## 3. Нефункциональные требования

- Код должен быть написан ясно и структурировано в соответствии с требованиями,
  указанными в разделе "Требования к ДЗ" информационного блока.
- Программа должна компилироваться и запускаться.
- Программа должна придерживаться fail-fast поведения.
- Программа должна обрабатывать лог-файлы эффективно, не загружая весь файл в память
- Программа должна логировать все важные события, которые происходят во время ее работы.
    - Логирование должно осуществляться в stdout.
    - Для логирования необходимо использовать `log4j` (подключен в шаблоне).
- В случае возникновения ошибок, в зависимости от их критичности, программа либо должна завершать свою работу,
  либо логировать факт возникновения подобного рода ситуации.
- Результат работы программы должен быть легко интерпретируемым человеком.
- Программа должна быть покрыта юнит-тестами. Минимальный уровень покрытия - **50%**.
    - Необходимо реализовать все стабы acceptance-тестов (тесты в пакете `acceptance`).
    - Каждый компонент программы должен быть легко-тестируем.
    - [Подробнее про тестирование тут](./TESTS.md).
- Программа проходит blackbox-тесты ([подробнее тут](./TESTS.md)).
- По возможности небходимо использовать готовые библиотеки для решения поставленных задач.
- В комментарии к MR должно быть дано краткое описание того, что было реализовано,
  а так же примеры работы вашей программы.

## Оценивание работы

Общее кол-во баллов за работу = 120 б. + 25 доп. б. + 18 доп. б. = **163 б.**

Дополнительные баллы:

- Реализация вывода статистики в формате `ADOC` - **10 б**.
- Сбор статистики распределения запрсов по дате - **10 б**.
- Расчет кол-ва уникальных протоколов передачи данных в логах - **5 б**.
- Участие в кросс-ревью работ других студентов - **18 б**.

## Полезные ссылки

- https://www.baeldung.com/java-read-lines-large-file
- https://openjdk.org/groups/net/httpclient/recipes.html
- https://www.baeldung.com/jackson-object-mapper-tutorial
- https://github.com/commonmark/commonmark-java
- https://www.baeldung.com/linux/status-codes
- https://www.baeldung.com/java-unit-testing-best-practices
- https://docs.oracle.com/javase/8/docs/api/java/io/BufferedReader.html#readLine--
- https://commons.apache.org/proper/commons-io/javadocs/api-2.5/org/apache/commons/io/LineIterator.html
- Подробнее о том, что такое перцентили и как их можно расчитать:
    - https://habr.com/ru/companies/tochka/articles/690814/
    - https://en.wikipedia.org/wiki/Percentile
    - Готовые решения:
        - https://github.com/newrelic-experimental/newrelic-sketch-java
        - https://github.com/DataDog/sketches-java
        - https://github.com/tdunning/t-digest
        - https://github.com/apache/datasketches-java
        - https://github.com/humio/ddsketch

Для дополнительной справки: [HELP.md](./HELP.md)
